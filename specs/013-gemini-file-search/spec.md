# Feature Specification: Gemini File Search Integration

**Feature Branch**: `013-gemini-file-search`
**Created**: 2025-12-30
**Version**: 1.0
**Status**: Draft
**Input**: User uploads files through ChatKit UI, files are stored in Gemini File Search API with embeddings, user queries files through chat using semantic search.

---

## 1. Overview

This feature enables users to upload files (PDF, Excel, CSV, Images, DOCX, MD, TXT) through ChatKit UI, store them in Google's Gemini File Search API (managed RAG), and query them using natural language through Schema Agent.

### Key Differentiator from Spec 012 (File Upload Processing)

| Aspect | Spec 012 (Local Processing) | Spec 013 (Gemini File Search) |
|--------|----------------------------|-------------------------------|
| Storage | Local server (24hr expiry) | Gemini API (permanent until deleted) |
| Search | Python libraries (pandas, pdfplumber) | Semantic vector search (Gemini) |
| Embeddings | None | Auto-generated by Gemini |
| Citations | None | Built-in grounding metadata |
| RAG | Manual implementation | Managed by Google |

---

## 2. Problem Statement

### Current State
- Users can upload files for local processing (Spec 012)
- Files expire after 24 hours
- No semantic search across multiple files
- No citation/source tracking in responses

### User Need
Users want to:
- Upload files that persist until manually deleted
- Search across ALL uploaded files semantically
- Get answers with citations showing source documents
- Have a managed RAG system without vector store setup

### Solution: Gemini File Search API Integration
A file search system that:
- Uses Gemini's FileSearchStore for permanent file storage
- Auto-generates embeddings and chunks files
- Provides semantic search with built-in citations
- Integrates as a direct tool in Schema Agent

---

## 3. Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              FRONTEND                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  ChatKit UI                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   "+" Button â†’ "Use File Search"                                    â”‚     â”‚
â”‚  â”‚                     â†“                                               â”‚     â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚   â”‚  File Search Modal                                           â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”‚  ðŸ“ Drag & Drop Files Here                              â”‚â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”‚  Supported: PDF, DOCX, Excel, CSV, MD, TXT, Images      â”‚â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚     â”‚
â”‚  â”‚   â”‚                                                              â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  My Files:                                                   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”‚ ðŸ“„ report.pdf          âœ… Ready to use         [ðŸ—‘ï¸]  â”‚   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”‚ ðŸ“Š data.xlsx           âœ… Ready to use         [ðŸ—‘ï¸]  â”‚   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â”‚ ðŸ“ notes.md            â³ Processing...              â”‚   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚     â”‚
â”‚  â”‚   â”‚                                                              â”‚  â”‚     â”‚
â”‚  â”‚   â”‚  [Upload More Files]                          [Close]        â”‚  â”‚     â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚   User types: "What does my PDF say about revenue?"                â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              BACKEND                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  File Search Router (/api/file-search/*)                           â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  POST /upload     â†’ Upload file to user's FileSearchStore          â”‚     â”‚
â”‚  â”‚  GET  /files      â†’ List user's files with status                  â”‚     â”‚
â”‚  â”‚  GET  /files/{id}/status â†’ Poll processing status                  â”‚     â”‚
â”‚  â”‚  DELETE /files/{id} â†’ Delete file from store                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                    â”‚                                         â”‚
â”‚                                    â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  FileSearchService                                                  â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  get_or_create_store(user_id)                                       â”‚     â”‚
â”‚  â”‚    â†’ Check DB for existing store                                    â”‚     â”‚
â”‚  â”‚    â†’ If none: create new FileSearchStore in Gemini                  â”‚     â”‚
â”‚  â”‚    â†’ Save store_id to DB                                            â”‚     â”‚
â”‚  â”‚    â†’ Return store                                                   â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  upload_file(user_id, file)                                         â”‚     â”‚
â”‚  â”‚    â†’ Get user's store                                               â”‚     â”‚
â”‚  â”‚    â†’ Upload to Gemini FileSearchStore                               â”‚     â”‚
â”‚  â”‚    â†’ Poll operation.done                                            â”‚     â”‚
â”‚  â”‚    â†’ Update DB status: "ready"                                      â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  search_files(user_id, query)                                       â”‚     â”‚
â”‚  â”‚    â†’ Get user's store                                               â”‚     â”‚
â”‚  â”‚    â†’ Call generateContent with file_search tool                     â”‚     â”‚
â”‚  â”‚    â†’ Extract grounding_metadata for citations                       â”‚     â”‚
â”‚  â”‚    â†’ Return answer + citations                                      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                    â”‚                                         â”‚
â”‚                                    â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Schema Agent                                                       â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  Tools:                                                             â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ execute_sql (existing)                                        â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ list_tables (existing)                                        â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ google_search (existing)                                      â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ gmail_connector (existing)                                    â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ gdrive_connector (existing)                                   â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ notion_connector (existing)                                   â”‚     â”‚
â”‚  â”‚  â””â”€â”€ file_search (NEW) â† Direct function tool                      â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  @function_tool                                                     â”‚     â”‚
â”‚  â”‚  async def file_search(query: str, user_id: int) -> str:            â”‚     â”‚
â”‚  â”‚      """Search user's uploaded files"""                             â”‚     â”‚
â”‚  â”‚      service = FileSearchService()                                  â”‚     â”‚
â”‚  â”‚      result = await service.search_files(user_id, query)            â”‚     â”‚
â”‚  â”‚      return format_with_citations(result)                           â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GEMINI FILE SEARCH API (Google Managed)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  FileSearchStore: "fileSearchStores/user_123_store"                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  Documents (Auto-chunked + Embedded):                               â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ report.pdf     â†’ [embedding_1, embedding_2, ...]              â”‚     â”‚
â”‚  â”‚  â”œâ”€â”€ data.xlsx      â†’ [embedding_1, embedding_2, ...]              â”‚     â”‚
â”‚  â”‚  â””â”€â”€ notes.md       â†’ [embedding_1, embedding_2, ...]              â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â”‚  Query: "What about revenue?"                                       â”‚     â”‚
â”‚  â”‚           â†“                                                         â”‚     â”‚
â”‚  â”‚  Semantic Vector Search                                             â”‚     â”‚
â”‚  â”‚           â†“                                                         â”‚     â”‚
â”‚  â”‚  Retrieved Chunks + Grounding Metadata                              â”‚     â”‚
â”‚  â”‚           â†“                                                         â”‚     â”‚
â”‚  â”‚  Gemini generates answer with citations                             â”‚     â”‚
â”‚  â”‚                                                                     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                              â”‚
â”‚  Features:                                                                   â”‚
â”‚  â€¢ Automatic chunking and embedding generation                               â”‚
â”‚  â€¢ Semantic similarity search                                                â”‚
â”‚  â€¢ Built-in citations (grounding_metadata)                                   â”‚
â”‚  â€¢ Permanent storage (until manual delete)                                   â”‚
â”‚  â€¢ No vector database setup required                                         â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. User Stories

### User Story 1 - Upload Files for Search (Priority: P1)

As a user, I want to upload files through ChatKit so that I can search them using natural language.

**Acceptance Scenarios**:

1. **Given** I am in ChatKit, **When** I click "+" button, **Then** I see "Use File Search" option
2. **Given** I click "Use File Search", **When** the modal opens, **Then** I see a drag-and-drop zone and my existing files
3. **Given** I drop a PDF file, **When** upload starts, **Then** I see "Processing..." status
4. **Given** file processing completes, **When** I view the file list, **Then** I see "Ready to use" status
5. **Given** I have uploaded files, **When** I close the modal, **Then** files remain available for future queries

---

### User Story 2 - One Store Per User (Priority: P1)

As a user, I want all my files stored in one place so that I can search across all documents together.

**Acceptance Scenarios**:

1. **Given** I upload my first file, **When** the system processes it, **Then** a FileSearchStore is created for me (one-time)
2. **Given** I already have files uploaded, **When** I upload more files, **Then** they go to my existing store (same ID)
3. **Given** I have multiple files, **When** I search, **Then** the search covers ALL my files

---

### User Story 3 - Query Files Through Chat (Priority: P1)

As a user, I want to ask questions about my uploaded files in natural language.

**Acceptance Scenarios**:

1. **Given** I have files uploaded, **When** I ask "What does my PDF say about X?", **Then** Schema Agent uses the file_search tool
2. **Given** the agent searches my files, **When** it finds relevant content, **Then** I see an answer with citations
3. **Given** the agent responds, **When** I look at citations, **Then** I see which file(s) the answer came from
4. **Given** I have no files uploaded, **When** I try to search, **Then** I see "Please upload files first"

---

### User Story 4 - Delete Files (Priority: P2)

As a user, I want to delete files I no longer need.

**Acceptance Scenarios**:

1. **Given** I view my files, **When** I click delete on a file, **Then** I see a confirmation prompt
2. **Given** I confirm deletion, **When** the delete completes, **Then** the file is removed from list and Gemini store
3. **Given** a file is deleted, **When** I search, **Then** that file's content is no longer searchable

---

### User Story 5 - View Processing Status (Priority: P2)

As a user, I want to see the status of my file uploads.

**Acceptance Scenarios**:

1. **Given** I upload a file, **When** processing starts, **Then** I see "Processing..." with a spinner
2. **Given** processing completes, **When** the status updates, **Then** I see "Ready to use" with checkmark
3. **Given** processing fails, **When** the status updates, **Then** I see "Failed" with error message

---

## 5. Technical Requirements

### 5.1 Supported File Types

| File Type | Extensions | Max Size | Notes |
|-----------|------------|----------|-------|
| PDF | .pdf | 100 MB | Text + tables extracted |
| Excel | .xlsx, .xls | 100 MB | All sheets processed |
| CSV | .csv | 100 MB | Tabular data |
| Word | .docx, .doc | 100 MB | Text extracted |
| Markdown | .md | 100 MB | Full text |
| Text | .txt | 100 MB | Plain text |
| Images | .png, .jpg, .jpeg, .gif, .webp | 100 MB | OCR by Gemini |

### 5.2 Gemini File Search API Usage

```python
from google import genai
from google.genai import types

client = genai.Client(api_key=GEMINI_API_KEY)

# 1. Create FileSearchStore (one per user)
file_search_store = client.file_search_stores.create(
    config=types.CreateFileSearchStoreConfig(
        display_name=f"user_{user_id}_files"
    )
)

# 2. Upload file to store
operation = client.file_search_stores.upload_to_file_search_store(
    file_search_store_name=file_search_store.name,
    file=file_path,
    config=types.UploadToFileSearchStoreConfig(
        display_name=filename
    )
)

# 3. Wait for processing
while not operation.done:
    time.sleep(2)
    operation = client.operations.get(operation)

# 4. Query with file_search tool
response = client.models.generate_content(
    model="gemini-2.5-flash",
    contents=query,
    config=types.GenerateContentConfig(
        tools=[types.Tool(
            file_search=types.FileSearch(
                file_search_store_names=[file_search_store.name]
            )
        )]
    )
)

# 5. Extract citations
grounding = response.candidates[0].grounding_metadata
citations = []
if grounding and grounding.grounding_chunks:
    for chunk in grounding.grounding_chunks:
        citations.append({
            "source": chunk.retrieved_context.title,
            "text": chunk.retrieved_context.text
        })
```

### 5.3 Database Models

```python
# backend/app/models.py

class UserFileSearchStore(Base):
    """One FileSearchStore per user - created on first upload"""
    __tablename__ = "user_file_search_stores"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), unique=True)
    gemini_store_id: Mapped[str] = mapped_column(String(255))  # "fileSearchStores/abc123"
    display_name: Mapped[str] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)

    # Relationship
    documents: Mapped[List["UserFileDocument"]] = relationship(
        back_populates="store",
        cascade="all, delete-orphan"
    )


class UserFileDocument(Base):
    """Track each uploaded document"""
    __tablename__ = "user_file_documents"

    id: Mapped[int] = mapped_column(primary_key=True)
    store_id: Mapped[int] = mapped_column(ForeignKey("user_file_search_stores.id"))
    gemini_doc_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    original_filename: Mapped[str] = mapped_column(String(255))
    display_name: Mapped[str] = mapped_column(String(255))
    mime_type: Mapped[str] = mapped_column(String(100))
    file_size: Mapped[int] = mapped_column(Integer)
    status: Mapped[str] = mapped_column(String(20), default="processing")  # processing, ready, failed
    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)

    # Relationship
    store: Mapped["UserFileSearchStore"] = relationship(back_populates="documents")
```

### 5.4 API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/file-search/upload` | POST | Upload file to user's store |
| `/api/file-search/files` | GET | List user's files |
| `/api/file-search/files/{id}/status` | GET | Get file processing status |
| `/api/file-search/files/{id}` | DELETE | Delete file from store |

### 5.5 Schema Agent Tool

```python
@function_tool
async def file_search(query: str, user_id: int) -> str:
    """
    Search through user's uploaded files to find relevant information.

    Use this tool when user asks about their uploaded documents, PDFs,
    Excel files, or any files they've added through File Search.

    Args:
        query: The search query to find information in uploaded files
        user_id: The user's ID (automatically injected)

    Returns:
        Answer with citations from the user's files
    """
```

---

## 6. Implementation Details

### 6.1 FileSearchService

```python
# backend/app/services/file_search_service.py

class FileSearchService:
    """Service for Gemini File Search API operations"""

    def __init__(self):
        self.client = genai.Client(api_key=settings.GEMINI_API_KEY)

    async def get_or_create_store(
        self,
        user_id: int,
        db: AsyncSession
    ) -> UserFileSearchStore:
        """Get existing store or create new one (ONE per user)"""

        # Check if user already has a store
        result = await db.execute(
            select(UserFileSearchStore).where(
                UserFileSearchStore.user_id == user_id
            )
        )
        store = result.scalar_one_or_none()

        if store:
            return store

        # Create new store in Gemini
        gemini_store = self.client.file_search_stores.create(
            config=types.CreateFileSearchStoreConfig(
                display_name=f"user_{user_id}_files"
            )
        )

        # Save to DB
        store = UserFileSearchStore(
            user_id=user_id,
            gemini_store_id=gemini_store.name,
            display_name=f"User {user_id} Files"
        )
        db.add(store)
        await db.commit()
        await db.refresh(store)

        return store

    async def upload_file(
        self,
        user_id: int,
        file: UploadFile,
        db: AsyncSession
    ) -> UserFileDocument:
        """Upload file to user's FileSearchStore"""

        # 1. Get or create store
        store = await self.get_or_create_store(user_id, db)

        # 2. Save file temporarily
        temp_path = f"/tmp/{uuid.uuid4()}_{file.filename}"
        content = await file.read()
        with open(temp_path, "wb") as f:
            f.write(content)

        # 3. Create DB record with "processing" status
        doc = UserFileDocument(
            store_id=store.id,
            original_filename=file.filename,
            display_name=file.filename,
            mime_type=file.content_type or "application/octet-stream",
            file_size=len(content),
            status="processing"
        )
        db.add(doc)
        await db.commit()
        await db.refresh(doc)

        # 4. Upload to Gemini (background task)
        asyncio.create_task(
            self._process_upload(store, doc, temp_path, db)
        )

        return doc

    async def _process_upload(
        self,
        store: UserFileSearchStore,
        doc: UserFileDocument,
        file_path: str,
        db: AsyncSession
    ):
        """Background task: Upload and wait for embedding"""
        try:
            # Upload to Gemini FileSearchStore
            operation = self.client.file_search_stores.upload_to_file_search_store(
                file_search_store_name=store.gemini_store_id,
                file=file_path,
                config=types.UploadToFileSearchStoreConfig(
                    display_name=doc.display_name
                )
            )

            # Poll for completion (max 5 minutes)
            max_wait = 300
            waited = 0
            while not operation.done and waited < max_wait:
                await asyncio.sleep(2)
                waited += 2
                operation = self.client.operations.get(operation)

            if not operation.done:
                raise TimeoutError("File processing timed out")

            # Update status to "ready"
            doc.status = "ready"
            doc.gemini_doc_id = getattr(operation.result, 'name', None)
            await db.commit()

        except Exception as e:
            doc.status = "failed"
            doc.error_message = str(e)
            await db.commit()
            logger.error(f"File upload failed for doc {doc.id}: {e}")

        finally:
            # Cleanup temp file
            if os.path.exists(file_path):
                os.remove(file_path)

    async def search_files(
        self,
        user_id: int,
        query: str,
        db: AsyncSession
    ) -> dict:
        """Search user's files and return answer with citations"""

        # Get user's store
        result = await db.execute(
            select(UserFileSearchStore).where(
                UserFileSearchStore.user_id == user_id
            )
        )
        store = result.scalar_one_or_none()

        if not store:
            return {
                "answer": "You haven't uploaded any files yet. Please upload files first using the 'Use File Search' option in the + menu.",
                "citations": []
            }

        # Check if user has any ready files
        docs_result = await db.execute(
            select(UserFileDocument).where(
                UserFileDocument.store_id == store.id,
                UserFileDocument.status == "ready"
            )
        )
        docs = docs_result.scalars().all()

        if not docs:
            return {
                "answer": "Your files are still processing. Please wait a moment and try again.",
                "citations": []
            }

        # Query with File Search
        response = self.client.models.generate_content(
            model="gemini-2.5-flash",
            contents=query,
            config=types.GenerateContentConfig(
                tools=[types.Tool(
                    file_search=types.FileSearch(
                        file_search_store_names=[store.gemini_store_id]
                    )
                )]
            )
        )

        # Extract citations
        citations = []
        if response.candidates:
            grounding = response.candidates[0].grounding_metadata
            if grounding and grounding.grounding_chunks:
                for chunk in grounding.grounding_chunks:
                    citations.append({
                        "source": chunk.retrieved_context.title,
                        "text": chunk.retrieved_context.text[:300] + "..."
                               if len(chunk.retrieved_context.text) > 300
                               else chunk.retrieved_context.text
                    })

        return {
            "answer": response.text,
            "citations": citations
        }

    async def list_files(
        self,
        user_id: int,
        db: AsyncSession
    ) -> List[UserFileDocument]:
        """List all files for user"""

        result = await db.execute(
            select(UserFileSearchStore).where(
                UserFileSearchStore.user_id == user_id
            )
        )
        store = result.scalar_one_or_none()

        if not store:
            return []

        docs_result = await db.execute(
            select(UserFileDocument)
            .where(UserFileDocument.store_id == store.id)
            .order_by(UserFileDocument.created_at.desc())
        )
        return docs_result.scalars().all()

    async def delete_file(
        self,
        user_id: int,
        doc_id: int,
        db: AsyncSession
    ) -> bool:
        """Delete file from Gemini and DB"""

        # Get document
        result = await db.execute(
            select(UserFileDocument)
            .join(UserFileSearchStore)
            .where(
                UserFileDocument.id == doc_id,
                UserFileSearchStore.user_id == user_id
            )
        )
        doc = result.scalar_one_or_none()

        if not doc:
            return False

        # Delete from Gemini (if has gemini_doc_id)
        if doc.gemini_doc_id:
            try:
                self.client.file_search_stores.documents.delete(
                    name=doc.gemini_doc_id,
                    config=types.DeleteDocumentConfig(force=True)
                )
            except Exception as e:
                logger.warning(f"Failed to delete from Gemini: {e}")

        # Delete from DB
        await db.delete(doc)
        await db.commit()

        return True
```

### 6.2 API Router

```python
# backend/app/routers/file_search.py

from fastapi import APIRouter, UploadFile, File, Depends, HTTPException
from ..services.file_search_service import FileSearchService
from ..dependencies import get_current_user, get_db

router = APIRouter(prefix="/api/file-search", tags=["file-search"])

ALLOWED_TYPES = {
    "application/pdf",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.ms-excel",
    "text/csv",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/msword",
    "text/markdown",
    "text/plain",
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
}

MAX_FILE_SIZE = 100 * 1024 * 1024  # 100 MB


@router.post("/upload")
async def upload_file(
    file: UploadFile = File(...),
    current_user = Depends(get_current_user),
    db = Depends(get_db)
):
    """Upload file to user's FileSearchStore"""

    # Validate file type
    if file.content_type not in ALLOWED_TYPES:
        raise HTTPException(
            status_code=400,
            detail=f"File type {file.content_type} not supported"
        )

    # Check file size
    content = await file.read()
    await file.seek(0)  # Reset for service to read

    if len(content) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=413,
            detail=f"File size exceeds maximum {MAX_FILE_SIZE // (1024*1024)}MB"
        )

    service = FileSearchService()
    doc = await service.upload_file(current_user.id, file, db)

    return {
        "id": doc.id,
        "filename": doc.original_filename,
        "status": doc.status,
        "message": "File uploaded. Processing embeddings..."
    }


@router.get("/files")
async def list_files(
    current_user = Depends(get_current_user),
    db = Depends(get_db)
):
    """List all user's uploaded files"""

    service = FileSearchService()
    docs = await service.list_files(current_user.id, db)

    return {
        "files": [
            {
                "id": doc.id,
                "filename": doc.original_filename,
                "status": doc.status,
                "size": doc.file_size,
                "mime_type": doc.mime_type,
                "created_at": doc.created_at.isoformat(),
                "error": doc.error_message
            }
            for doc in docs
        ]
    }


@router.get("/files/{doc_id}/status")
async def get_file_status(
    doc_id: int,
    current_user = Depends(get_current_user),
    db = Depends(get_db)
):
    """Check file processing status (for polling)"""

    from sqlalchemy import select
    from ..models import UserFileDocument, UserFileSearchStore

    result = await db.execute(
        select(UserFileDocument)
        .join(UserFileSearchStore)
        .where(
            UserFileDocument.id == doc_id,
            UserFileSearchStore.user_id == current_user.id
        )
    )
    doc = result.scalar_one_or_none()

    if not doc:
        raise HTTPException(status_code=404, detail="File not found")

    return {
        "id": doc.id,
        "status": doc.status,
        "error": doc.error_message
    }


@router.delete("/files/{doc_id}")
async def delete_file(
    doc_id: int,
    current_user = Depends(get_current_user),
    db = Depends(get_db)
):
    """Delete a file"""

    service = FileSearchService()
    success = await service.delete_file(current_user.id, doc_id, db)

    if not success:
        raise HTTPException(status_code=404, detail="File not found")

    return {"success": True, "message": "File deleted"}
```

### 6.3 Schema Agent Integration

```python
# backend/app/agents/tools/file_search_tool.py

from agents import function_tool
from app.services.file_search_service import FileSearchService

def create_file_search_tool(db_session_factory):
    """Create file_search tool with DB session factory"""

    @function_tool
    async def file_search(query: str, user_id: int) -> str:
        """
        Search through user's uploaded files to find relevant information.

        Use this tool when user asks about their uploaded documents, PDFs,
        Excel files, Word documents, or any files they've added through
        the File Search feature.

        Examples of when to use this tool:
        - "What does my PDF say about revenue?"
        - "Summarize my uploaded document"
        - "Find information about X in my files"
        - "What are the key points from my Excel file?"

        Args:
            query: The search query to find information in uploaded files
            user_id: The user's ID (automatically injected)

        Returns:
            Answer with citations from the user's files
        """
        service = FileSearchService()

        async with db_session_factory() as db:
            result = await service.search_files(user_id, query, db)

        # Format response with citations
        response = result["answer"]

        if result["citations"]:
            response += "\n\n**Sources:**\n"
            for i, cite in enumerate(result["citations"], 1):
                response += f"{i}. **{cite['source']}**: {cite['text']}\n"

        return response

    return file_search
```

---

## 7. Frontend Components

### 7.1 File Upload Modal

```tsx
// frontend/components/file-search/FileSearchModal.tsx

import { useState, useEffect, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';

interface FileDocument {
  id: number;
  filename: string;
  status: 'processing' | 'ready' | 'failed';
  size: number;
  mime_type: string;
  created_at: string;
  error?: string;
}

export function FileSearchModal({
  isOpen,
  onClose
}: {
  isOpen: boolean;
  onClose: () => void;
}) {
  const [files, setFiles] = useState<FileDocument[]>([]);
  const [uploading, setUploading] = useState(false);

  // Fetch files on open
  useEffect(() => {
    if (isOpen) {
      fetchFiles();
    }
  }, [isOpen]);

  const fetchFiles = async () => {
    const res = await fetch('/api/file-search/files', {
      headers: { Authorization: `Bearer ${getToken()}` }
    });
    const data = await res.json();
    setFiles(data.files);
  };

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    setUploading(true);

    for (const file of acceptedFiles) {
      const formData = new FormData();
      formData.append('file', file);

      try {
        const res = await fetch('/api/file-search/upload', {
          method: 'POST',
          headers: { Authorization: `Bearer ${getToken()}` },
          body: formData
        });

        if (res.ok) {
          const doc = await res.json();
          setFiles(prev => [doc, ...prev]);
          pollStatus(doc.id);
        }
      } catch (error) {
        console.error('Upload failed:', error);
      }
    }

    setUploading(false);
  }, []);

  const pollStatus = async (docId: number) => {
    const interval = setInterval(async () => {
      const res = await fetch(`/api/file-search/files/${docId}/status`, {
        headers: { Authorization: `Bearer ${getToken()}` }
      });
      const { status } = await res.json();

      if (status === 'ready' || status === 'failed') {
        clearInterval(interval);
        fetchFiles();
      }
    }, 2000);
  };

  const handleDelete = async (docId: number) => {
    if (!confirm('Delete this file?')) return;

    await fetch(`/api/file-search/files/${docId}`, {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${getToken()}` }
    });

    fetchFiles();
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/pdf': ['.pdf'],
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel': ['.xls'],
      'text/csv': ['.csv'],
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
      'text/markdown': ['.md'],
      'text/plain': ['.txt'],
      'image/*': ['.png', '.jpg', '.jpeg', '.gif', '.webp']
    }
  });

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <div className="modal-header">
          <h2>File Search</h2>
          <button onClick={onClose}>Close</button>
        </div>

        {/* Drag & Drop Zone */}
        <div {...getRootProps()} className={`dropzone ${isDragActive ? 'active' : ''}`}>
          <input {...getInputProps()} />
          <p>Drag & drop files here, or click to select</p>
          <small>PDF, Excel, CSV, Word, Markdown, Text, Images</small>
        </div>

        {/* File List */}
        <div className="file-list">
          <h3>My Files</h3>
          {files.length === 0 ? (
            <p>No files uploaded yet</p>
          ) : (
            files.map(file => (
              <div key={file.id} className="file-item">
                <div className="file-info">
                  <span className="file-name">{file.filename}</span>
                  <span className="file-size">
                    {(file.size / 1024).toFixed(1)} KB
                  </span>
                </div>

                <div className="file-status">
                  {file.status === 'processing' && (
                    <span className="status-processing">Processing...</span>
                  )}
                  {file.status === 'ready' && (
                    <span className="status-ready">Ready to use</span>
                  )}
                  {file.status === 'failed' && (
                    <span className="status-failed" title={file.error}>
                      Failed
                    </span>
                  )}

                  <button
                    onClick={() => handleDelete(file.id)}
                    className="delete-btn"
                  >
                    Delete
                  </button>
                </div>
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}
```

### 7.2 ChatKit Integration

Add "Use File Search" to the + button dropdown in ChatKit:

```tsx
// In ChatKit composer tools menu

const fileSearchTool = {
  id: 'file_search',
  label: 'Use File Search',
  icon: <SearchIcon />,
  onClick: () => setFileSearchModalOpen(true)
};
```

---

## 8. Environment Configuration

### 8.1 Required Environment Variables

```env
# Gemini API (already exists)
GEMINI_API_KEY=your-gemini-api-key
```

### 8.2 Dependencies

```txt
# backend/requirements.txt (additions)
google-genai>=1.49.0  # For File Search API support
```

---

## 9. Security Requirements

- **SR-001**: Files are uploaded directly to Gemini API, not stored locally
- **SR-002**: Each user has isolated FileSearchStore (no cross-user access)
- **SR-003**: User authentication required for all endpoints
- **SR-004**: File size validated before upload (max 100MB)
- **SR-005**: File type validated against allowed list

---

## 10. Error Handling

| Scenario | Error Code | Message |
|----------|------------|---------|
| Unsupported file type | 400 | "File type X not supported" |
| File too large | 413 | "File size exceeds maximum 100MB" |
| Processing timeout | 504 | "File processing timed out" |
| No files uploaded | 200 | "Please upload files first" |
| File not found | 404 | "File not found" |
| Gemini API error | 500 | "Failed to process file" |

---

## 11. Success Criteria

- **SC-001**: User can upload a file and have it ready for search within 60 seconds (for files < 10MB)
- **SC-002**: File list displays all user files with correct status
- **SC-003**: Search returns relevant answers with citations
- **SC-004**: Deleted files are removed from both DB and Gemini
- **SC-005**: Multiple files can be searched in single query
- **SC-006**: No cross-user file access possible

---

## 12. Testing Strategy

### Unit Tests
- FileSearchService methods
- File type validation
- File size validation

### Integration Tests
- Upload â†’ Process â†’ Search flow
- Delete file flow
- API endpoint contracts

### End-to-End Tests
- Frontend upload modal
- Status polling
- Chat query with file_search tool

---

## 13. Out of Scope (v1.0)

- File editing/updating
- File sharing between users
- Metadata filtering (genre, author)
- Custom chunking configuration
- Multiple FileSearchStores per user
- File preview in modal
- Bulk delete

---

## Appendix A: Gemini File Search Limits

| Limit | Value |
|-------|-------|
| Max file size | 100 MB |
| Max stores per project | 10 |
| Free tier storage | 1 GB |
| Tier 1 storage | 10 GB |
| Tier 2 storage | 100 GB |
| Tier 3 storage | 1 TB |
| Embedding cost | $0.15 / million tokens |

---

## Appendix B: Example User Flow

```
1. User clicks "+" in ChatKit
2. User selects "Use File Search"
3. File Search Modal opens
4. User drags "annual_report.pdf" to dropzone
5. UI shows: "annual_report.pdf - Processing..."
6. After ~30 seconds: "annual_report.pdf - Ready to use"
7. User closes modal
8. User types: "What are the key findings in my report?"
9. Schema Agent uses file_search tool
10. Response: "Based on annual_report.pdf, the key findings are:
    1. Revenue increased by 23%
    2. Customer base grew by 15%
    ...

    **Sources:**
    1. **annual_report.pdf**: 'The fiscal year showed remarkable growth with revenue increasing by 23% compared to...'"
```
